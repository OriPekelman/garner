module Garner
  module Mixins
    module Grape
      #
      # A cache that supports conditional GETs
      #
      # Borrows generously from http://themomorohoax.com/2009/01/07/using-stale-with-rails-to-return-304-not-modified
      # See also RFC 2616: http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4
      #   for explanation of how If-Modified-Since and If-None-Match request headers are handled.
      #
      module Cache
      
        def cache_enabled?
          true
        end
  
        # cache a record
        def cache(binding = nil, context = {}, &block)
          unless cache_enabled?
            yield
          else
            Garner::Cache::ObjectIdentity.cache(binding, cache_context(context)) do
              yield
            end
          end
        end
        
        # invalidate a cache record
        def invalidate(*args)
          Garner::Cache::ObjectIdentity.invalidate(* args)
        end
  
        def cache_or_304(binding = nil, context = {}, &block)
          cache_context = cache_context(context)
          # metadata written in a previous GET
          metadata = Garner::Cache::ObjectIdentity.cache_metadata(binding, cache_context)
          error!("Not Modified", 304) if metadata && fresh?(metadata)
          rc = cache(binding, context, &block)
          # metadata has been generated by cache
          metadata = Garner::Cache::ObjectIdentity.cache_metadata(binding, cache_context)
          self.last_modified = metadata[:last_modified]
          self.etag = metadata[:etag]
          rc
        end
  
        private
        
          # @override
          def cache_context(context)
            (context || {}).merge({
              :request => request
            })
          end

          def fresh?(metadata = {})
            case
            when if_modified_since && if_none_match
              not_modified?(metadata[:last_modified]) && etag_matches?(metadata[:etag])
            when if_modified_since
              not_modified?(metadata[:last_modified])
            when if_none_match
              etag_matches?(metadata[:etag])
            else
              false
            end
          end
    
          def if_modified_since
            if since = env["HTTP_IF_MODIFIED_SINCE"]
              Time.rfc2822(since) rescue nil
            end
          end

          def if_none_match
            env["HTTP_IF_NONE_MATCH"]
          end

          def not_modified?(modified_at)
            if_modified_since && modified_at && if_modified_since >= modified_at
          end

          def etag_matches?(etag)
            if_none_match && if_none_match == etag
          end
        
          def last_modified=(utc_time)
            return unless utc_time
            header "Last-Modified", utc_time.httpdate
          end
        
          def etag=(etag)
            return unless etag
            header "ETag", etag
          end
          
      end
    end
  end 
end

